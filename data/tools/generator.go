// generator.go - Generate Go code from JSON data
// Usage: go run generator.go
//
//go:generate go run generator.go
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"text/template"
)

// BlockData represents a block in JSON format
type BlockData struct {
	ID       int     `json:"id"`
	Name     string  `json:"name"`
	Solid    bool    `json:"solid"`
	Hardness float64 `json:"hardness"`
}

// ItemData represents an item in JSON format
type ItemData struct {
	ID         int    `json:"id"`
	Name       string `json:"name"`
	StackSize  int    `json:"stackSize"`
	Durability int    `json:"durability"`
}

// EntityData represents an entity in JSON format
type EntityData struct {
	ID     int32   `json:"id"`
	Name   string  `json:"name"`
	Width  float64 `json:"width"`
	Height float64 `json:"height"`
}

var blocksTemplate = `// Code generated by tools/generator.go from JSON data; DO NOT EDIT.
package data

// BlockNameToID maps block names to their numeric IDs (Minecraft {{ .Version }})
var BlockNameToID = map[string]int{
{{- range $name, $block := .Blocks }}
	"{{ $name }}": {{ $block.ID }}, // {{ $block.Name }}
{{- end }}
}

// IsSolidMap stores whether each block is solid (Minecraft {{ .Version }})
var IsSolidMap = map[int]bool{
{{- range $name, $block := .Blocks }}
	{{- if $block.Solid }}
	{{ $block.ID }}: true, // {{ $block.Name }}
	{{- end }}
{{- end }}
}

// HardnessMap stores block hardness values (Minecraft {{ .Version }})
var HardnessMap = map[int]float64{
{{- range $name, $block := .Blocks }}
	{{ $block.ID }}: {{ printf "%.1f" $block.Hardness }}, // {{ $block.Name }}
{{- end }}
}

// IsSolid checks if a block ID is solid
func IsSolid(id int) bool {
	return IsSolidMap[id]
}

// GetHardness returns the hardness of a block
func GetHardness(id int) float64 {
	if h, ok := HardnessMap[id]; ok {
		return h
	}
	return -1.0
}
`

var itemsTemplate = `// Code generated by tools/generator.go from JSON data; DO NOT EDIT.
package data

// ItemNameToID maps item names to their numeric IDs (Minecraft {{ .Version }})
var ItemNameToID = map[string]int{
{{- range $name, $item := .Items }}
	"{{ $name }}": {{ $item.ID }}, // {{ $item.Name }}
{{- end }}
}

// StackSizeMap stores maximum stack sizes for items (Minecraft {{ .Version }})
var StackSizeMap = map[int]int{
{{- range $name, $item := .Items }}
	{{ $item.ID }}: {{ $item.StackSize }}, // {{ $item.Name }}
{{- end }}
}

// DurabilityMap stores maximum durability for items (Minecraft {{ .Version }})
var DurabilityMap = map[int]int{
{{- range $name, $item := .Items }}
	{{- if gt $item.Durability 0 }}
	{{ $item.ID }}: {{ $item.Durability }}, // {{ $item.Name }}
	{{- end }}
{{- end }}
}

// GetMaxStackSize returns the maximum stack size for an item
func GetMaxStackSize(id int) int {
	if size, ok := StackSizeMap[id]; ok {
		return size
	}
	return 1 // Default stack size
}

// GetMaxDurability returns the maximum durability for an item
func GetMaxDurability(id int) int {
	if dur, ok := DurabilityMap[id]; ok {
		return dur
	}
	return 0 // No durability
}
`

var entitiesTemplate = `// Code generated by tools/generator.go from JSON data; DO NOT EDIT.
package data

// EntityNameToID maps entity names to their type IDs (Minecraft {{ .Version }})
var EntityNameToID = map[string]int32{
{{- range $name, $entity := .Entities }}
	"{{ $name }}": {{ $entity.ID }}, // {{ $entity.Name }}
{{- end }}
}

// EntityIDToName maps entity type IDs to their names (Minecraft {{ .Version }})
var EntityIDToName = map[int32]string{
{{- range $name, $entity := .Entities }}
	{{ $entity.ID }}: "{{ $name }}", // {{ $entity.Name }}
{{- end }}
}
`

func main() {
	// For now, generate for 1.21.10 (can be extended for multi-version)
	version := "1.21.10"

	// Determine base directory (works both when run directly and via go generate)
	// Check if minecraft_data exists in current directory
	baseDir := "."
	if _, err := os.Stat("minecraft_data"); os.IsNotExist(err) {
		// minecraft_data not in current dir, we're in tools/
		baseDir = ".."
	}

	versionDir := filepath.Join(baseDir, "minecraft_data", version)

	fmt.Printf("Generating Go code from %s data...\n", version)

	// Generate blocks.go
	if err := generateBlocks(versionDir, version, baseDir); err != nil {
		fmt.Printf("❌ Error generating blocks: %v\n", err)
		os.Exit(1)
	}

	// Generate items.go
	if err := generateItems(versionDir, version, baseDir); err != nil {
		fmt.Printf("❌ Error generating items: %v\n", err)
		os.Exit(1)
	}

	// Generate entities.go
	if err := generateEntities(versionDir, version, baseDir); err != nil {
		fmt.Printf("❌ Error generating entities: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("✅ Code generation complete!")
}

func generateBlocks(versionDir, version, baseDir string) error {
	// Read JSON
	data, err := os.ReadFile(filepath.Join(versionDir, "blocks.json"))
	if err != nil {
		return err
	}

	var blocks map[string]BlockData
	if err := json.Unmarshal(data, &blocks); err != nil {
		return err
	}

	// Sort names for consistent output
	names := make([]string, 0, len(blocks))
	for name := range blocks {
		names = append(names, name)
	}
	sort.Strings(names)

	// Create sorted map
	sortedBlocks := make(map[string]BlockData)
	for _, name := range names {
		sortedBlocks[name] = blocks[name]
	}

	// Generate code
	tmpl, err := template.New("blocks").Parse(blocksTemplate)
	if err != nil {
		return err
	}

	outputFile := filepath.Join(baseDir, "blocks.go")
	file, err := os.Create(outputFile)
	if err != nil {
		return err
	}
	defer func(file *os.File) {
		err := file.Close()
		if err != nil {
			fmt.Printf("❌ Error closing file: %v\n", err)
			os.Exit(1)
		}
	}(file)

	return tmpl.Execute(file, map[string]interface{}{
		"Version": version,
		"Blocks":  sortedBlocks,
	})
}

func generateItems(versionDir, version, baseDir string) error {
	// Read JSON
	data, err := os.ReadFile(filepath.Join(versionDir, "items.json"))
	if err != nil {
		return err
	}

	var items map[string]ItemData
	if err := json.Unmarshal(data, &items); err != nil {
		return err
	}

	// Sort names
	names := make([]string, 0, len(items))
	for name := range items {
		names = append(names, name)
	}
	sort.Strings(names)

	sortedItems := make(map[string]ItemData)
	for _, name := range names {
		sortedItems[name] = items[name]
	}

	// Generate code
	tmpl, err := template.New("items").Parse(itemsTemplate)
	if err != nil {
		return err
	}

	outputFile := filepath.Join(baseDir, "items.go")
	file, err := os.Create(outputFile)
	if err != nil {
		return err
	}
	defer func(file *os.File) {
		err := file.Close()
		if err != nil {
			fmt.Printf("❌ Error closing file: %v\n", err)
			os.Exit(1)
		}
	}(file)

	return tmpl.Execute(file, map[string]interface{}{
		"Version": version,
		"Items":   sortedItems,
	})
}

func generateEntities(versionDir, version, baseDir string) error {
	// Read JSON
	data, err := os.ReadFile(filepath.Join(versionDir, "entities.json"))
	if err != nil {
		return err
	}

	var entities map[string]EntityData
	if err := json.Unmarshal(data, &entities); err != nil {
		return err
	}

	// Sort names
	names := make([]string, 0, len(entities))
	for name := range entities {
		names = append(names, name)
	}
	sort.Strings(names)

	sortedEntities := make(map[string]EntityData)
	for _, name := range names {
		sortedEntities[name] = entities[name]
	}

	// Generate code
	tmpl, err := template.New("entities").Parse(entitiesTemplate)
	if err != nil {
		return err
	}

	outputFile := filepath.Join(baseDir, "entities.go")
	file, err := os.Create(outputFile)
	if err != nil {
		return err
	}
	defer func(file *os.File) {
		err := file.Close()
		if err != nil {
			fmt.Printf("❌ Error closing file: %v\n", err)
			os.Exit(1)
		}
	}(file)

	return tmpl.Execute(file, map[string]interface{}{
		"Version":  version,
		"Entities": sortedEntities,
	})
}
